{"componentChunkName":"component---src-templates-blog-post-js","path":"/Etc/부동소수점(Floating_Point_System)_알아보기!(feat.ft_printf)/","result":{"data":{"site":{"siteMetadata":{"author":"JaeSeoKim","comment":{"utterances":"JaeSeoKim/jaeseokim.github.io"},"sponsor":{"buyMeACoffeeId":"jaeseokim"}}},"markdownRemark":{"excerpt":"일단 부동소수점(Floating Point System)이란 컴퓨터에서 실수를 표현하는 방법 중 하나이다. 기본적으로 부동소수점이란 움직이지 않는다는 뜻의 부동이 아닌 자유 롭게 떠다닌다는 의미의 부동(浮動)이다. 즉 부동소수점이라는 것은 2bit로 표현을 할 때 소수점 위치에 대해 가변적으로 조절을 하여 사용한다고 이해를 하면 된다. 부동소수점(Floa…","html":"<p>일단 부동소수점(Floating Point System)이란 컴퓨터에서 실수를 표현하는 방법 중 하나이다.</p>\n<p>기본적으로 부동소수점이란 움직이지 않는다는 뜻의 부동이 아닌 자유 롭게 떠다닌다는 의미의 부동(浮動)이다.</p>\n<p>즉 부동소수점이라는 것은 2bit로 표현을 할 때 소수점 위치에 대해 가변적으로 조절을 하여 사용한다고 이해를 하면 된다.</p>\n<p>부동소수점(Floating Point System)은 IEEE에서 제안한 표준을 대부분 따르고 있는데 이 표준에 대하여 알아본다.</p>\n<h1 id=\"ieee-floating-point-standard-ieee-754\" style=\"position:relative;\"><a href=\"#ieee-floating-point-standard-ieee-754\" aria-label=\"ieee floating point standard ieee 754 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IEEE Floating Point Standard (IEEE 754)</h1>\n<p>IEEE 754에서는 표현 하게 되는 수의 정밀도에 따라 32bit(4byte)의 단 정밀도(single-precision) 64bit(8byte)의 배 정밀도(double-precision)로 형식 뿐만 아니라 79bit(약 10byte) 이상으로 (보통 80bit로 구현됨) 이루어진 확장 정밀도(extended-precision) 등 다양하게 정의 하고 있다.</p>\n<p>이 때 <code>C</code> 에서 사용하는 <code>float</code> 이 단 정밀도(single-precision)에 해당하게 되고 <code>double</code> 이 배 정밀도(double-precision), <code>long double</code> 이 확장 정밀도(extended-precision)에 해당하게 된다.</p>\n<h2 id=\"정의\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%9D%98\" aria-label=\"정의 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정의</h2>\n<p>EEE 754 부동소수점 표기 표준은 다음과 같이 항목들을 정의한다.</p>\n<ul>\n<li>산술 형식: 유한한 수들(0을 포함한)과 무한대와 NaN(Not a number)값으로 구성된 2진수와 10진수의 부동소수점 데이터 집합</li>\n<li>형식의 교환: 부동소수점 데이터를 효율적이고 압축적으로 전환할 수도 있는 인코딩</li>\n<li>반올림 규칙: 산수와 전환의 과정에서 반올림을 할 때의 성질</li>\n<li>작동: 산수와 산술 형식의 처리 방법 형식</li>\n<li>예외 처리: 예외적인 조건의 표기 (0으로의 나누는 작업, 오버플로 등)</li>\n</ul>\n<p>IEEE 754에 이 외에도 더 복잡한 예외 처리, 추가적인 작업(삼각함수 등), 표현의 평가, 그리고 생산 가능한 결과의 성취를 위한 여러 방법이 포함되어 있다.</p>\n<h2 id=\"실수의-표현\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%EC%88%98%EC%9D%98-%ED%91%9C%ED%98%84\" aria-label=\"실수의 표현 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실수의 표현</h2>\n<p>IEEE 754에서 정의한 표현 형식을 보게 되면 아래와 같이 비트 화 하여 저장하게 된다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">값</th>\n<th align=\"left\">저장</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">단정밀도(single-precision)</td>\n<td align=\"left\">sign bit, 8-bit exponent, 23-bit significand</td>\n</tr>\n<tr>\n<td align=\"left\">배정밀도(double-precision)</td>\n<td align=\"left\">sign bit, 11-bit exponent, 52-bit significand</td>\n</tr>\n<tr>\n<td align=\"left\">확장정밀도(extended-precision)</td>\n<td align=\"left\">sign bit, 15-bit exponent, Integer bit, 63-bit significand</td>\n</tr>\n</tbody>\n</table>\n<p>아래의 예제들은 모두 비트가 적은 float를 기준으로 설명하겠습니다!</p>\n<p><code>IEEE 754</code> 에서 정의한 부동 소수점은 아래와 같은 형태로 비트를 저장을 하게 된다.</p>\n<table>\n<thead>\n<tr>\n<th>Sign</th>\n<th>Exponent</th>\n<th>Significand</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1bit</td>\n<td>8bit</td>\n<td>23bit</td>\n</tr>\n</tbody>\n</table>\n<p><code>IEEE 754</code> 는 총 3가지의 값에 따라 각기 다른 인코딩 방법을 통해 표현을 하도록 정의가 되어 있다.</p>\n<p>일단 첫번째로 설명할 방법은 <code>Special value</code> 이다.</p>\n<h2 id=\"special-value\" style=\"position:relative;\"><a href=\"#special-value\" aria-label=\"special value permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Special value</h2>\n<p>Special Value는 <code>nan</code>, <code>inf</code> <code>-inf</code> 를 표현을 할 때 사용이 된다.\n일단 Special value 값이 라는 조건은 <code>Exponent</code> 가 전부 1일때 작동을 하게 된다.</p>\n<p>그 후 <code>significand</code> 가 0으로 전부 채워져 있다면 <code>inf</code> 로 분류가 되고 이때에 <code>sign</code> 에 따라서 <code>-inf</code> <code>inf</code> 로 나뉘어 지게 된다.</p>\n<p>위의 <code>significand</code> 가 0으로 전부 채워진 경우가 아닌 나머지 경우는 <code>nan</code> 즉 숫자가 아닌 것으로 취급을 하게 된다.</p>\n<h2 id=\"normalized-value\" style=\"position:relative;\"><a href=\"#normalized-value\" aria-label=\"normalized value permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Normalized value</h2>\n<p>Noemalized value는 <code>exp</code> 가 1 또는 0 으로만 채워져 있는 경우가 아니라면 <code>Normalized value</code> 방식으로 인코딩으로 표현이 된 방식이다.</p>\n<p>예를 들어 0.625라는 값을 <code>IEEE 754</code> 형태로 인코딩을 할때 아래처럼 진행을 하게 되는데 일딴 정수 부분이 0 이기 때문에 넘어가게 되고 그 다음 실수 부분에 대하여 비트로 저장을 해야 하는데 간단하게 설명을 하면 각 비트는 <code>(2 ^ n / 1)</code> 형태로 표현을 하게 된다.</p>\n<p>즉 0.625는 0.101로 표현을 하게 된다!  </p>\n<p>이때 정규화 과정을 거치게 되는데 여기서 정규화는 맨 앞에 정수 부분 비트를 1비트를 만들도록 shift 연산을 시키는 것을 말한다.</p>\n<p>정규화를 진행하게 되면 1.01로 표현이 되고 여기서 정규화를 진행하게 된 모든 값들은 첫 비트가 1이 되기 때문에 1를 제외한 나머지 01를 저장하게 된다.</p>\n<p>최종적으로 <code>significand</code> 는 <code>01000000000000000000000</code>  이 저장되게 된다.</p>\n<p>그렇다면 이제 남은 것은 <code>exponent</code> 인데 이 부분은 아까전에 정규화 과정을 통해 얼만큼 shift 이동이 되었는지에 대해 저장을 하게 된다.</p>\n<p>이때 이동된 거리는 <code>-1</code> 로 <code>&#x3C;&#x3C;</code> 연산을 통해 이동을 했을 때를 기준으로 한다. 그리고 <code>exponent</code> 에 저장하기 전에 <code>bias</code> 를 더하는 과정을 진행해야 하는데 이때의 bias는 <code>2 ^ (exp_bit수 - 1) - 1</code> 로 계산이 된다.</p>\n<p>즉  exponent에는 -1 + 127의 값 126이 저장되게 된다.</p>\n<p>최종적으로 bit를 보게 되면 아래와 같이 완성이 된다.</p>\n<table>\n<thead>\n<tr>\n<th>Sign</th>\n<th>Exponent</th>\n<th>Significand</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>01111110</td>\n<td>01000000000000000000000</td>\n</tr>\n</tbody>\n</table>\n<p>위의 연산과정을 간단하게 정리를 해본다면 아래와 같이 정리가 된다.</p>\n<ol>\n<li>10진수에서 2진수로 변환을 한다. (Ex. 0.625 -> 0.101)</li>\n<li>정수부 첫 비트가 1이 되도록 정규화를 진행한다. (Ex. 0.101 &#x3C;&#x3C; -1)</li>\n<li>2단계에서 구해진 실수 부의 bit를 significand에 저장을 한다.</li>\n<li>2단계에서 이동한 비트 만큼을 bias를 더하여 exponent에 저장을 한다. (Ex. -1 + 127 =  126)</li>\n<li>저장하는 수의 부호를 sign에 저장을 한다.</li>\n</ol>\n<h2 id=\"denormalized-value\" style=\"position:relative;\"><a href=\"#denormalized-value\" aria-label=\"denormalized value permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Denormalized value</h2>\n<p>Denormalized value는 <code>exp</code> 가 0으로 채워져 있는 경우를 표현을 하게 된다.</p>\n<p>이때에는 0을 표현을 하거나 매우 작은 소수점을 표현을 할때 사용을 하게 된다.</p>\n<p>이때에는 특별하게 기존에 1을 붙여서 사용하지 않고 0으로 취급되어서 사용을 하게 된다.</p>\n<h2 id=\"문자열로-표현을-하기-feat-ft_printf\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4%EB%A1%9C-%ED%91%9C%ED%98%84%EC%9D%84-%ED%95%98%EA%B8%B0-feat-ft_printf\" aria-label=\"문자열로 표현을 하기 feat ft_printf permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열로 표현을 하기! Feat. ft_printf</h2>\n<p>이제 이렇게 위에서 정리한 내용을 바탕으로 현재 <code>42seoul</code> 에서 진행하는 <code>ft_printf</code> 에서 사용을 할 수 있는 방법을 구상 해 본다.</p>\n<p>일단 printf에서의 <code>%f</code> 를 표현하기 위해서는 <code>dtoa</code> 함수의 구현이 필요하게 되는데 이때 위에서 정리한 내용을 바탕으로 구현이 가능하다.</p>\n<p>일단 <code>double</code> 에서 표현해야 하는 수의 범위는 기존 자료형으로는 표현이 불가능하기 때문에 char 또는 int의 크기로 배열을 선언하여 각 자리수 별로 각각 저장하여 사용을 하게 된다.</p>\n<p>이렇게 저장된 자료형을 이용하여 값을 알아 내는 방법은 약간은 단순 무식 하지만 아래의 로직을 사용하면 정확한 bit의 값을 알 수 있다.</p>\n<p>예를 들어서 0.615의 경우를 예를 들어서 설명을 한다.</p>\n<p>일단  bias의 최대값까지 저장 할 수 있는 <code>1023</code> 크기를 가진 배열을 선언하고 전부 0으로 초기화 작업을 진행을 한다.</p>\n<p>그리고 0.615의 경우는 Nomalized value 이기 때문에 배열의 0번째에 1로 넣어두고 exp - bias 한 값 만큼 이동된 위체에 <code>siginificand</code> 의 비트를 차례대로 저장을 합니다.</p>\n<pre class=\"grvsc-container one-dark-pro\" data-language=\"\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">1 0 1 0 0 0 0 ........ 0</span></span></code></pre>\n<p> 위와 같은 형태로 저장이 되어 있는데 이제 각 자리수의 비트를 <code>5 ^ n</code> 의 값으로 계산을 하고 그 값을 더하여 배열에 저장을 한다.</p>\n<p>즉 첫번째 비트에서는 5이기 때문에 5를 저장하게 되고 두번째 비트는 0이므로 skip 3번째 비트는 1이므로 125를 더하여 저장을 한다.</p>\n<pre class=\"grvsc-container one-dark-pro\" data-language=\"\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">6 2 5 0 0 0  ......... 0</span></span></code></pre>\n<p>연산이 끝나게 되면 아래와 같이 최종적으로 구현이 되는데 이제 여기서 필요한 precision 만큼 잘라서 사용을 하면 된다. </p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .one-dark-pro {\n    background-color: #282c34;\n    color: #abb2bf;\n  }\n  .one-dark-pro .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","tableOfContents":"<ul>\n<li>\n<p><a href=\"/Etc/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90(Floating_Point_System)_%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0!(feat.ft_printf)/#ieee-floating-point-standard-ieee-754\">IEEE Floating Point Standard (IEEE 754)</a></p>\n<ul>\n<li><a href=\"/Etc/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90(Floating_Point_System)_%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0!(feat.ft_printf)/#%EC%A0%95%EC%9D%98\">정의</a></li>\n<li><a href=\"/Etc/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90(Floating_Point_System)_%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0!(feat.ft_printf)/#%EC%8B%A4%EC%88%98%EC%9D%98-%ED%91%9C%ED%98%84\">실수의 표현</a></li>\n<li><a href=\"/Etc/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90(Floating_Point_System)_%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0!(feat.ft_printf)/#special-value\">Special value</a></li>\n<li><a href=\"/Etc/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90(Floating_Point_System)_%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0!(feat.ft_printf)/#normalized-value\">Normalized value</a></li>\n<li><a href=\"/Etc/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90(Floating_Point_System)_%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0!(feat.ft_printf)/#denormalized-value\">Denormalized value</a></li>\n<li><a href=\"/Etc/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90(Floating_Point_System)_%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0!(feat.ft_printf)/#%EB%AC%B8%EC%9E%90%EC%97%B4%EB%A1%9C-%ED%91%9C%ED%98%84%EC%9D%84-%ED%95%98%EA%B8%B0-feat-ft_printf\">문자열로 표현을 하기! Feat. ft_printf</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"2020년 11월 08일","title":"부동소수점(Floating Point System) 알아보기!(feat.ft_printf)","tags":["IEEE 754","42seoul","ft_printf"]}}},"pageContext":{"slug":"/Etc/부동소수점(Floating_Point_System)_알아보기!(feat.ft_printf)/","previous":{"fields":{"slug":"/Javascript/badge42-개발기_3_aka_42-readme-stats/"},"frontmatter":{"title":"[Javascript] badge42 개발기(3) aka.42-readme-stats"}},"next":{"fields":{"slug":"/C/C-vscode_debugger_사용하기!/"},"frontmatter":{"title":"[C] vscode debugger 사용하기!"}}}},"staticQueryHashes":["1081905842","63159454"]}